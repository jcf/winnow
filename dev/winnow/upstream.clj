(ns winnow.upstream
  (:require
   [clojure.data :as data]
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [clojure.pprint :as pp]
   [clojure.set :as set]
   [clojure.string :as str]))

(def ^:private source-url
  "https://raw.githubusercontent.com/tailwindlabs/tailwindcss/main/packages/tailwindcss/src/utilities.ts")

(def ^:private baseline-file
  "dev-resources/winnow/tailwind-utilities.edn")

(def ^:private patterns
  [#"staticUtility\(['\"]([^'\"]+)['\"]"
   #"functionalUtility\(['\"]([^'\"]+)['\"]"
   #"spacingUtility\(\s*['\"]([^'\"]+)['\"]"
   #"colorUtility\(\s*['\"]([^'\"]+)['\"]"
   #"utilities\.static\(\s*['\"]([^'\"]+)['\"]"
   #"utilities\.functional\(\s*['\"]([^'\"]+)['\"]"])

(def ^:private loop-expansions
  "Utilities generated by for-loops in utilities.ts"
  (let [inset   ["inset" "inset-x" "inset-y" "inset-s" "inset-e" "inset-bs" "inset-be"
                 "top" "right" "bottom" "left"]
        margin  ["m" "mx" "my" "ms" "me" "mbs" "mbe" "mt" "mr" "mb" "ml"]
        padding ["p" "px" "py" "ps" "pe" "pbs" "pbe" "pt" "pr" "pb" "pl"]
        scroll-m ["scroll-m" "scroll-mx" "scroll-my" "scroll-ms" "scroll-me"
                  "scroll-mbs" "scroll-mbe" "scroll-mt" "scroll-mr" "scroll-mb" "scroll-ml"]
        scroll-p ["scroll-p" "scroll-px" "scroll-py" "scroll-ps" "scroll-pe"
                  "scroll-pbs" "scroll-pbe" "scroll-pt" "scroll-pr" "scroll-pb" "scroll-pl"]
        border  ["border" "border-x" "border-y" "border-s" "border-e"
                 "border-bs" "border-be" "border-t" "border-r" "border-b" "border-l"]
        rounded ["rounded" "rounded-s" "rounded-e" "rounded-t" "rounded-r" "rounded-b" "rounded-l"
                 "rounded-ss" "rounded-se" "rounded-es" "rounded-ee"
                 "rounded-tl" "rounded-tr" "rounded-bl" "rounded-br"]
        sizing  (for [p ["size" "w" "h" "min-w" "min-h" "max-w" "max-h"]
                      k ["full" "svw" "lvw" "dvw" "svh" "lvh" "dvh" "min" "max" "fit" "auto"]]
                  (str p "-" k))
        logical (for [p ["inline" "block" "min-inline" "max-inline" "min-block" "max-block"]
                      k ["full" "min" "max" "fit" "auto"]]
                  (str p "-" k))
        axes    ["x" "y" "z"]]
    (into #{}
          cat
          [(mapcat (fn [n] [n (str n "-auto") (str n "-full") (str "-" n "-full") (str "-" n)]) inset)
           (mapcat (fn [n] [n (str n "-auto") (str "-" n)]) margin)
           padding
           (mapcat (fn [n] [n (str "-" n)]) scroll-m)
           scroll-p
           border
           (mapcat (fn [n] [n (str n "-none") (str n "-full")]) rounded)
           sizing
           logical
           (mapcat (fn [a] [(str "translate-" a) (str "-translate-" a)
                            (str "translate-" a "-full") (str "-translate-" a "-full")]) axes)
           (mapcat (fn [a] [(str "scale-" a) (str "-scale-" a)]) axes)
           (mapcat (fn [a] [(str "rotate-" a) (str "-rotate-" a)]) axes)
           ["gap" "gap-x" "gap-y" "space-x" "space-y" "-space-x" "-space-y"]])))

(defn parse
  [source]
  (into loop-expansions
        (comp (mapcat #(re-seq % source))
              (map second)
              (remove #(str/starts-with? % "$")))
        patterns))

(defn fetch-upstream
  []
  (into (sorted-set)
        (parse (slurp source-url))))

(defn load-baseline
  []
  (let [f (io/file baseline-file)]
    (when (.exists f)
      (edn/read-string (slurp f)))))

(defn write-baseline!
  []
  (let [utilities (fetch-upstream)
        data      {:source source-url
                   :utilities utilities}]
    (io/make-parents baseline-file)
    (spit baseline-file (with-out-str (pp/pprint data)))
    data))

(defn diff
  []
  (let [baseline (:utilities (load-baseline))
        upstream (fetch-upstream)]
    (when baseline
      {:added   (set/difference upstream baseline)
       :removed (set/difference baseline upstream)})))

(defn -main
  [& args]
  (case (first args)
    "update" (do (write-baseline!)
                 (println "Updated" baseline-file))
    "check"  (let [{:keys [added removed]} (diff)]
               (if (and (empty? added) (empty? removed))
                 (println "No changes")
                 (do (pp/pprint {:added added :removed removed})
                     (System/exit 1))))
    (println "Usage: update | check")))

(comment
  (write-baseline!)
  (diff)
  (fetch-upstream))
